#### **1、JavaScript中什么是基本数据类型？什么是引用数据类型？数据类型如何进行存储的？**

基本数据类型有：`Number,String,Boolean,Null,Undefined,Symbol(ES6新增，表示独一无二的值),bigInt`

引用数据类型有：`Object,Array,Date,Function,RegExp`

基本数据类型存储在栈中；引用数据类型存储在堆中，在栈中保存数据的引用地址

------

#### **2、在JS中为什么0.3+0.2<0.5?**

在js中，浮点数是用64位固定长度表示的，只有后面的52位表示尾数位，因此出现了精度缺失，将它从内存中取出来再转换成十进制就不是0.1了

使0.3+0.2 === 0.5的方法，先放大倍数，再缩小相应倍数

------

#### **3、判断数据类型有几种方法？**

- `typeof`

缺点：`typeof null`的值为`Object`，无法分辨`null`和`object`

原因：在JavaScript中，不同的对象是用二进制进行存储的，如果二进制前三位都是0，就会被判断为`object`类型，而`null`的前三位都是0

- `instanceof`

缺点：只能判断对象是否在目标对象的原型链上

原理：实际上就是查找目标对象的原型链

- `constructor`


- `Object.prototype.toString.call()`

缺点：不能细分谁是谁的实例

------

#### **4、`==`和`===`的区别？**

`===`是严格意义上的相等，会比较两边数据类型和值的大小

`==`是非严格意义上的相等，两边类型不同会进行进一步比较

------

#### **5、什么是作用域？什么是作用域链？**

作用域：规定变量和函数可使用的范围

作用域链：每个函数都有一个作用域链，查找变量或函数时，需要从局部作用域到全局作用域依次查找，这些作用域的集合为作用域链

------

#### **6、什么是闭包？**

闭包的本质就是在一个函数内部创建另一个函数

优点：

1. 保护函数内的变量安全，防止命名冲突；
2. 在内存中维持一个变量，当作缓存；
3. 匿名自执行函数可以减少消耗；

缺点：

1. 增大内存消耗，造成内存泄漏；
2. 由于涉及跨域访问，会导致性能损失；

应用：

1. 设计模式中的单例模式；
2. for循环中保留i的操作；
3. 函数柯里化；
4. 防抖和节流；

------

#### **7、什么是原型？什么是原型链？**

原型：分为隐式原型和显式原型，每一个对象都有一个隐式原型，它指向自己构造函数的显式原型；

原型链：多个`__proto__`组成的集合成为原型链

- 所有实例的`__proto__`都指向他们构造函数的`prototype`
- 所有的`prototype`都是对象，自然它的`__proto__`指向的是`Object()`的`prototype`
- 所有的构造函数的隐式原型指向的都是`Function()`的显示原型
- Object的隐式原型是null

------

#### **8、什么是内存泄漏？为什么会导致内存泄漏？**

内存泄漏指不再使用的内存没有被及时释放出来，导致该段内存无法被使用；

原因是我们无法通过js访问某个对象，但是垃圾回收机制认为该对象还在被引用，因此垃圾回收机制不会释放该对象；

------

#### **9、垃圾回收机制有哪些策略？**

- 标记清除法

垃圾回收机制获取根并标记它们，然后访问并标记所有来自它们的引用，然后再访问这些对象并标记它们的引用，如此递进，最终发现没有被标记的进行删除；

- 引用计数法

当声明一个变量并给该变量赋值一个引用类型的值时候，该值的计数+1，当该值赋值给另一个变量的时候，该计数+1，当该值被其他值取代的时候，该计数-1，当计数变为0的时候，说明无法访问该值了，垃圾回收机制清除该对象；

缺点：当两个对象循环引用时，引用计数无法进行，因此被标记清除法取代

------

#### **10、为什么JS是单线程的？**

因为JS里面有可视的DOM，如果是多线程，一个线程在删除DOM节点，另一个在增加DOM节点，浏览器就不知道听谁的了

------

#### **11、宏任务和微任务有哪些？都是怎样执行的？**

- 宏任务：`script`、`setTimeOut`、`setInterval`、`setImmediate`
- 微任务:`promise.then`,`process.nextTick`、`Object.observe`、`MutationObserver`

注意：`promise`是同步任务

1. 执行宏任务script；
2. 进入script后，所有的同步任务主线程执行；
3. 所有宏任务放入宏任务执行队列；
4. 所有微任务放入微任务执行队列；
5. 先清空微任务队列；
6. 再取一个宏任务，执行，再清空微任务队列；
7. 依次循环

```js
setTimeout(function(){ //宏任务，分到宏任务Event Queue中
    console.log('1')
});
new Promise(function(resolve){ //主线程任务，直接打印2
    console.log('2');
    resolve();
}).then(function(){ //微任务，分到微任务Event Queue中
    console.log('3')
});
console.log('4'); //主线程任务，直接打印4
new Promise(function(resolve){
    console.log('5'); //主线程任务，直接打印5
    resolve();
}).then(function(){
    console.log('6') //微任务，分到微任务Event Queue中
    //微任务Event Queue中代码执行完，就执行宏任务Event Queue中代码，也是先进先出，依次打印1，7
});
setTimeout(function(){ //宏任务，分到宏任务Event Queue中
    console.log('7')
});
function bar(){
    console.log('8')
    foo()
}
function foo(){
    console.log('9')
    //主线程中任务执行完后，就要执行分发到微任务Event Queue中代码，实行先进先出，所以依次打印3，6
}
console.log('10') 
bar()
//结果：2，4，5，10，8，9，3，6，1，7
```

------

#### 12、`NaN === NaN`返回的是什么？

返回`false`，判断是否为NaN可以用一个函数`isNaN`来判断

------

#### 13、手写一个new

```js
function myNew(fn,...args){
  //1、创建一个空对象
  let obj = {};
  //2、使空对象的隐式原型指向原函数的显式原型
  obj._proto_ = fn.prototype;
  //3、改变 this的指向，指向新obj，并保存执行结果 result
  let result = fn.apply(obj , args);
  //4、判断执行函数的结果是不是null或Undefined，如果是则返回之前的新对象，如果不是则返回result
  return result instanceof Object ? result : obj
}
```

------

#### 14、说说JS常用的继承方式有哪些？以及优缺点？

1. 原型继承：把父类的实例作为子类的原型，缺点：子类的实例共享了父类构造函数的引用属性，不能传参
2. 组合继承：在子函数中运行父函数，要利用call将this改变一下，缺点：调用了两次父类的构造函数，造成了不必要的消耗，优点：可以传参
3. 寄生组合继承：最优方式，减少构造次数，减少性能开销
4. `Extends`：寄生组合继承的语法糖

------

#### 15、箭头函数和普通函数的区别？箭头函数能当作构造函数new吗？

- this的指向问题，箭头函数的this指向它定义时的对象，而不是调用它的对象
- 不会进行函数提升
- 没有 `arguments`对象，不能使用`arguments`，要获取参数可以使用`rest`运算符
- 不能作为生成器`Generator`使用
- 不能new 

> 1、没有自己的this，不能调用 call和apply
>
> 2、没有prototype，new关键字内部需要把新对象的`_proto_`指向函数的prototype

------

#### 16、JS有哪些常见的设计模式？

- 单例模式：不管创建多少个对象都只有一个实例
- 工厂模式：批量制作属性相同的实例对象，指向不同
- 构造函数模式
- 发布订阅者模式
- 代理模式
- 迭代器模式

------

#### 17、`setTimeOut`的第三个参数是什么？

可以作为参数传给函数，一般用于for循环赋值

------

#### 18、什么是暂时性死区？

暂时性死区是指，当进入一个作用域，我去使用一个变量名，而这个变量名已经存在了，但是是不可获取的，就会报错，造成暂时性死区，会影响`let`、`const`、`import`、`class`、`typeof`等的可用性

------

#### 19、如何实现大文件上传？

使用 input 接收大文件，使用`file.slice`进行分割分块上传（制定好一个块的大小，然后进行分割），等所有块上传完毕之后，`promise.all()`,运行成功回调

------

#### 20、JS性能优化的方式有哪些？

- 垃圾回收
- 清除闭包中的对象
- 防抖节流
- 分批加载
- 事件委托
- requestAnimationFrame的使用


- script标签中的defer和async


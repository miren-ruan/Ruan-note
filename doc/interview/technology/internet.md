#### **1、讲一讲三次握手和四次挥手？**

三次握手指建立一个TCP连接时，需要客户端和服务器总共发送三个包，来确认双方的发送能力和接收能力是否正常。实质上就是连接服务器指定端口，建立TCP连接，同步连接双方的序列号和确认号

- 第一次握手：客户端给服务端发一个 `SYN` 报文，此时客户端处于 `SYN_SENT` 状态。


- 第二次握手：服务器收到客户端的 `SYN` 报文之后，给客户端返回一个`ACK+SYN`包，表示已收到`SYN`，并进入`SYN_RECEIVE`状态
- 第三次握手：客户端收到 `SYN` 报文之后，会发送一个 `ACK` 报文，表示已经收到了服务端的 `SYN` 报文，此时客户端和服务器都处于 `ESTABLISHED` 状态，双方建立起了连接

**不能两次握手的原因**：第一次握手服务器能确认客户端的发送能力和自己的接收能力是正常的，第二次握手客户端能确认服务器的发送能力和接收能力正常，但是服务器并不知道客户端的接收能力是否正常

**半连接队列**：服务器第一次收到客户端的 `SYN` 之后，就会处于 `SYN_RCVD` 状态，此时双方还没有完全建立其连接，服务器会把此种状态下请求连接放在一个队列里，我们把这种队列称之为半连接队列

- 第一次挥手：客户端向服务端发送一个`FIN`包，进入`FIN_WAIT1`状态；
- 第二次挥手：服务端收到后，向客户端发送`ACK`确认包，进入`CLOSE_WAIT`状态；客户端收到`ACK`包后进入`FIN_WAIT2`状态；
- 第三次挥手：服务端再把自己剩余没传完的数据发送给客户端，发送完毕后在发送一个`FIN+ACK`包，进入`LAST_ACK`（最后确认）状态；
- 第四次挥手：客户端收到`FIN+ACK`包后，再向服务端发送`ACK`包，在等待两个周期后在关闭连接；

**等待两个周期的理由**：因为最后客户端发的`ACK`包可能丢失，如果不等待2个周期的话，服务端在没收收到`ACK`包之前，会不停的重复发送`FIN`包而不关闭

------

#### **2、说说你了解的状态码？**

| 开头数字 | 状态    | 举例                          |
| ---- | ----- | --------------------------- |
| 2    | 成功    | 200                         |
| 3    | 重定向   | 301永久重定向；302临时重定向；304协商缓存   |
| 4    | 客户端错误 | 401未经许可，需要http认证；404请求资源不存在 |
| 5    | 服务端错误 | 500                         |

------

#### **3、网络OSI七层模型有哪些？TCP是哪一层？**

应用层，表示层，会话层，传输层，网络层，数据链路层，物理层

TCP属于传输层

------

#### **4、HTTP和HTTPS有什么区别？**

HTTP：无状态，无连接，而且是明文传输，不安全，端口是80；

HTTPS：传输内容加密，身份验证，保证数据完整性，端口是443；

------

#### **5、了解HTTPS的实现原理吗？**

- 客户端向服务端发送一个随机值，以及一个加密算法；
- 服务端收到后返回一个协商好的加密算法，以及另一个随机值；
- 服务端再发送一个公钥CA；
- 客户端收到后先验证CA是否有效，无效进行报错弹框，有效进行下一步；
- 客户端使用之前的两个随机值和一个预主密钥组成一个会话密钥，在通过服务端传来的公钥加密把会话密钥发送给服务端；
- 服务端收到后使用私钥解密，得到两个随机值和预主密钥，然后组装成会话密钥；
- 客户端在向服务端发起一条信息，这条信息使用会话秘钥加密，用来验证服务端时候能收到加密的信息；
- 服务端收到信息后返回一个会话秘钥加密的信息；
- 都收到以后SSL层连接建立成功；

------

#### **6、`localStorage`、`SessionStorage`、`cookie`、`session` 之间有什么区别？**

​        **localStorage**

- 生命周期：关闭浏览器后数据依然保留，除非手动清除，否则一直在

- 作用域：相同浏览器的不同标签在同源情况下可以共享localStorage

  **sessionStorage**

- 生命周期：关闭浏览器或者标签后即失效

- 作用域：只在当前标签可用，当前标签的`iframe`中同源可以共享

  **cookie**

- 是保存在客户端的，一般由后端设置值，可以设置过期时间

- 储存大小只有`4K`

- 一般用来保存用户的信息的

- 在http下cookie是明文传输的,较不安全

- cookie属性有

  1、`http-only`:不能被客户端更改访问，防止XSS攻击（保证cookie安全性的操作）

  2、`Secure`：只允许在https下传输

  3、`Max-age`: cookie生成后失效的秒数

  4、`expire`: cookie的最长有效时间，若不设置则cookie生命期与会话期相同

  **session**

- session是保存在服务端的

- session的运行依赖`sessionId`，而`sessionId`又保存在cookie中，所以如果禁用的cookie，session也是不能用的，不过硬要用也可以，可以把`sessionId`保存在URL中

- session一般用来跟踪用户的状态

- session 的安全性更高，保存在服务端，不过一般为使服务端性能更加，会考虑部分信息保存在cookie中

------

#### **7、`get`和`post`的区别？**

|      | get       | Post     |
| ---- | --------- | -------- |
| 缓存   | 可缓存       | 不可缓存     |
| 传参   | 一般放在body中 | 一般放在URL中 |
| 安全性  | 不安全       | 较为安全     |
| 参数长度 | 长度有限，较小   | 不受限制     |

------

#### **8、`tcp`和`udp`有什么区别？**

- 连接：tcp需要面向连接，udp不需要连接，tcp需要三次握手四次挥手；
- 可靠性：tcp是可靠传输，丢包会进行重传，udp是不可靠传输；
- 效率：udp实时性高，效率比tcp高；
- tcp是点对点的，udp支持一对一，一对多，多对多；
- 首部大小：tcp首部占20字节，udp首部占8字节；

------

#### **9、浏览器输入URL后都经历了什么？**

1. 浏览器先查看浏览器缓存、系统缓存、路由器缓存，如果有直接显示；
2. 如果没有，需要DNS解析，解析获取相应的IP地址；
3. 浏览器向服务器发起tcp连接，建立三次握手；
4. 成功后，浏览器向服务器发送http请求，请求数据包；
5. 服务器收到请求后，将数据返回至浏览器，浏览器收到HTTP响应；
6. 读取页面内容，浏览器渲染，解析html源码，生成Dom树、解析css样式、js交互；

------

#### **10、什么是回流？什么是重绘？**

- 回流
  - `render`树中一部分或全部元素需要改变尺寸、布局、或着需要隐藏而需要重新构建，这个过程叫做回流
  - 回流必将引起重绘
- 重绘
  - `render`树中一部分元素改变，而不影响布局的，只影响外观的，比如颜色。该过程叫做重绘
- 页面至少经历一次回流和重绘（第一次加载的时候）

------

#### 11、跨域的方式有哪些？特点是什么？

**跨域问题是由于javascript语言安全限制中的同源策略造成的**

- `JSONP`：没有被同源策略限制到，只能进行get请求
- `document.domain`：只能跨子域，需要相同的主域
- `window.name+iframe`：同一 window 下 name 是只有一个的，如果该 window 下还包含一个 iframe 也是共享的，这个时候就可以使用 window.name（只能接收字符，可以使用 JSON 格式）来进行数据的传输
- `CORS`：通过自定义请求头来让服务器和浏览器进行沟通
- `nginx代理跨域`：nginx模拟一个虚拟服务器，发送数据时，客户端—nginx—服务端，返回数据时，服务端—nginx—客户端

------

#### 12、了解http缓存吗？

##### 强缓存

客户端发起请求前，先查看强缓存的`cache- control`里的`max-age`，判断数据有没有过期，如果没有就直接使用该缓存，有些用户可能会在没有过期的时候就点了刷新按钮，这个时候浏览器就回去请求服务端，要想避免这样做，可以在`cache-control`里面加一个`immutable`.这样用户再怎么刷新，只要 `max-age` 没有过期就不会去请求资源

`public`：服务端返回数据的过程中可能会经过很多虚拟代理服务器，使用 public 就是允许它们缓存

`private`：不允许代理服务器缓存，允许客户端缓存

`no-cache`：不允许强缓存，可以协商缓存

`no-store`：不允许缓存

##### 协商缓存

浏览器加载资源时，没有强缓存，这时候就去请求服务器，去请求服务器的时候，会带着两个参数，一个是`If-None-Match`，也就是响应头中的`etag`属性，每个文件对应一个`etag`;另一个参数是`If-Modified-Since`,带着这两个参数去检验缓存是否真的过期，如果没有过期，则服务器会给浏览器返回一个304状态码，表示缓存没有过期，可以使用旧缓存。
`etag`的作用：有时候编辑了文件，但是没有修改，但是`last-modified`属性的时间就会改变，导致服务器会重新发送资源，但是`etag`的出现就完美的避免了这个问题，他是文件的唯一标识

------

#### 13、浏览器请求并发有限制，怎么处理？

- 雪碧图，给请求的icon合成到一张图片上
- 对js和css进行打包，资源合并
- 给资源做缓存
- 图片按需加载
- 给资源做Hash，请求到不同域下

------

#### 14、讲一讲登陆实现？

用户第一次登录的时候，后端生成该用户对应的token（唯一的并且有时效性的）并返回给前端，前端收到token之后存储在`localStorage`里面，并且记录用户的登录状态，下次在发送用户相关的请求的时候需要携带上token，后端给每个用户相关的接口都加上token校验。每次用户切换界面的时候都进行路由守卫的拦截验证，如果登录状态为true，则可以访问，如果为false，则不允许访问


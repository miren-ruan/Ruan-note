#### **1、JavaScript中什么是基本数据类型？什么是引用数据类型？数据类型如何进行存储的？**

基本数据类型有：`Number,String,Boolean,Null,Undefined,Symbol(ES6新增),big`

引用数据类型有：`Object,Array,Date,Function,RegExp`

基本数据类型存储在栈中；引用数据类型存储在堆中，在栈中保存数据的引用地址

------

#### **2、在JS中为什么0.3+0.2<0.5?**

在js中，浮点数是用64位固定长度表示的，只有后面的52位表示尾数位，因此出现了精度缺失，将它从内存中取出来再转换成十进制就不是0.1了

------

#### **3、判断数据类型有几种方法？**

- `typeof`

缺点：`typeof null`的值为`Object`，无法分辨`null`和`object`

原因：在JavaScript中，不同的对象是用二进制进行存储的，如果二进制前三位都是0，就会被判断为`object`类型，而`null`的前三位都是0

- `instanceof`

缺点：只能判断对象是否在目标对象的原型链上

原理：实际上就是查找目标对象的原型链

- `constructor`


- `Object.prototype.toString.call()`

缺点：不能细分谁是谁的实例

------

#### **4、`==`和`===`的区别？**

`===`是严格意义上的相等，会比较两边数据类型和值的大小

`==`是非严格意义上的相等，两边类型不同会进行进一步比较

------

#### **5、什么是作用域？什么是作用域链？**

作用域：规定变量和函数可使用的范围

作用域链：每个函数都有一个作用域链，查找变量或函数时，需要从局部作用域到全局作用域依次查找，这些作用域的集合为作用域链

------

#### **6、什么是闭包？**

闭包的本质就是在一个函数内部创建另一个函数

优点：

1. 保护函数内的变量安全，防止命名冲突；
2. 在内寸中维持一个变量，当作缓存；
3. 匿名自执行函数可以减少消耗；

缺点：

1. 增大内存消耗，造成内存泄漏；
2. 由于涉及跨域访问，会导致性能损失；

应用：

1. 设计模式中的单例模式；
2. for循环中保留i的操作；
3. 函数柯里化；
4. 防抖和节流；

------

#### **7、什么是原型？什么是原型链？**

原型：分为隐式原型和显式原型，每一个对象都有一个隐式原型，它指向自己构造函数的显式原型；

原型链：多个`__proto__`组成的集合成为原型链

- 所有实例的`__proto__`都指向他们构造函数的`prototype`
- 所有的`prototype`都是对象，自然它的`__proto__`指向的是`Object()`的`prototype`
- 所有的构造函数的隐式原型指向的都是`Function()`的显示原型
- Object的隐式原型是null

------

#### **8、什么是内存泄漏？为什么会导致内存泄漏？**

内存泄漏指不再使用的内存没有被及时释放出来，导致该段内存无法被使用；

原因是我们无法通过js访问某个对象，但是垃圾回收机制认为该对象还在被引用，因此垃圾回收机制不会释放该对象；

------

#### **9、垃圾回收机制有哪些策略？**

- 标记清除法

垃圾回收机制获取根并标记它们，然后访问并标记所有来自它们的引用，然后再访问这些对象并标记它们的引用，如此递进，最终发现没有被标记的进行删除；

- 引用计数法

当声明一个变量并给该变量赋值一个引用类型的值时候，该值的计数+1，当该值赋值给另一个变量的时候，该计数+1，当该值被其他值取代的时候，该计数-1，当计数变为0的时候，说明无法访问该值了，垃圾回收机制清除该对象；

缺点：当两个对象循环引用时，引用计数无法进行，因此被标记清除法取代

------

#### **10、为什么JS是单线程的？**

因为JS里面有可视的DOM，如果是多线程，一个线程在删除DOM节点，另一个在增加DOM节点，浏览器就不知道听谁的了

------

#### **11、宏任务和微任务有哪些？都是怎样执行的？**

- 宏任务：`script`、`setTimeOut`、`setInterval`、`setImmediate`
- 微任务:`promise.then`,`process.nextTick`、`Object.observe`、`MutationObserver`

注意：`promise`是同步任务

1. 执行宏任务script；
2. 进入script后，所有的同步任务主线程执行；
3. 所有宏任务放入宏任务执行队列；
4. 所有微任务放入微任务执行队列；
5. 先清空微任务队列；
6. 再取一个宏任务，执行，再清空微任务队列；
7. 依次循环

```js
setTimeout(function(){ //宏任务，分到宏任务Event Queue中
    console.log('1')
});
new Promise(function(resolve){ //主线程任务，直接打印2
    console.log('2');
    resolve();
}).then(function(){ //微任务，分到微任务Event Queue中
    console.log('3')
});
console.log('4'); //主线程任务，直接打印4
new Promise(function(resolve){
    console.log('5'); //主线程任务，直接打印5
    resolve();
}).then(function(){
    console.log('6') //微任务，分到微任务Event Queue中
    //微任务Event Queue中代码执行完，就执行宏任务Event Queue中代码，也是先进先出，依次打印1，7
});
setTimeout(function(){ //宏任务，分到宏任务Event Queue中
    console.log('7')
});
function bar(){
    console.log('8')
    foo()
}
function foo(){
    console.log('9')
    //主线程中任务执行完后，就要执行分发到微任务Event Queue中代码，实行先进先出，所以依次打印3，6
}
console.log('10') 
bar()
//结果：2，4，5，10，8，9，3，6，1，7
```

------

#### **12、`var`,`const`,`let`有什么区别？**

​        `var`

- var声明的变量可进行变量提升，let和const不会

- var可以重复声明

- var在非函数作用域中定义是挂在到window上的

  `let`

- let声明的变量只在局部起作用

- let防止变量污染

- 不可在声明

  `const`

- 具有let的所有特征

- 不可被改变

- 如果使用const声明的是对象的话，是可以修改对象里面的值的

------

#### **13、`ES6`和`common.js`的区别？**

- `commonjs`模块输出的是值的拷贝，而`ES6`输出的值是值的引用；
- `commonjs`是在运行时加载，是一个对象，`ES6`是在编译时加载，是一个代码块；
- `commonjs`的this指向当前模块，`ES6`的`this`指向`undefined`；

